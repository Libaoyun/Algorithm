import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 37. 解数独
 * 编写一个程序，通过填充空格来解决数独问题。
 * 数独的解法需 遵循如下规则：
 * 数字 1-9 在每一行只能出现一次。
 * 数字 1-9 在每一列只能出现一次。
 * 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
 * 数独部分空格内已填入了数字，空白格用 '.' 表示。
 * 和前题规则一样，就是这一题要解数独，上一题是判断否是有效数独
 */
public class cgSolveSudoku {

    // TODO 这里放到类下的私有变量是为了便于使用参数，否则每次回溯都要传递这些参数很麻烦
    // 如果想节省空间可以是[9][9]，但是记录每行、列、块对应的数字的时候就要-1了，这样才能下标0-8对应数字1-9
    static boolean[][] row = new boolean[9][10];
    // 这里用static如果在力扣执行的时候会报错，因为类变量是静态的，所以每次执行完都会被清空，在力扣需要private
    static boolean[][] col = new boolean[9][10];
    static boolean[][] box = new boolean[9][10];

    static boolean valid = false;
    static List<int[]> spaces = new ArrayList<int[]>();

    // TODO 下面的行列块是给方法2压缩空间用的
    static int[] line = new int[9];
    static int[] column = new int[9];
    // 这里九宫格可以用3*3的二维数组，也可以用9的一维数组，区别就是9可以压缩但是下标计算需要[(i/3)*3+j/3]，而3*3的数组只需要[i/3][j/3]即可
    static int[][] block = new int[3][3];

    public static void main(String[] args) {
        // TODO 要求求解数独后原地填充数组
        char[][] board = new char[][]{
//                {'5','3','.','.','7','.','.','.','.'},
//                {'6','.','.','1','9','5','.','.','.'},
//                {'.','9','8','.','.','.','.','6','.'},
//                {'8','.','.','.','6','.','.','.','3'},
//                {'4','.','.','8','.','3','.','.','1'},
//                {'7','.','.','.','2','.','.','.','6'},
//                {'.','6','.','.','.','.','2','8','.'},
//                {'.','.','.','4','1','9','.','.','5'},
//                {'.','.','.','.','8','.','.','7','9'},
                {'.', '.', '9', '7', '4', '8', '.', '.', '.'},
                {'7', '.', '.', '.', '.', '.', '.', '.', '.'},
                {'.', '2', '.', '1', '.', '9', '.', '.', '.'},
                {'.', '.', '7', '.', '.', '.', '2', '4', '.'},
                {'.', '6', '4', '.', '1', '.', '5', '9', '.'},
                {'.', '9', '8', '.', '.', '.', '3', '.', '.'},
                {'.', '.', '.', '8', '.', '3', '.', '2', '.'},
                {'.', '.', '.', '.', '.', '.', '.', '.', '6'},
                {'.', '.', '.', '2', '7', '5', '9', '.', '.'}
        };
        solveSudoku2(board);
        System.out.println(Arrays.deepToString(board));
//        System.out.println(1 << 4);
    }


    /** 93%， 40%
     * 方法1：回溯算法
     * 先两层for循环整个遍历一遍数独，定义space记录每个空格的位置以及row.col.box
     * 分别记录row行的数字x，col列的数字x，以及第box个九宫格的数组x并进行标记
     * 然后递归遍历空格，从1-9尝试填充，如果合法就继续递归遍历下一个空格，否则回溯，并将当前已填充数字的数量-1，即回溯到上一个状态
     * 回溯或递归终止条件就是当前已填充数字的数量和空格的数量相同，也就意味着全都填充完毕了。
     */
    public static void solveSudoku(char[][] board) {

        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == '.') {
                    spaces.add(new int[]{i, j});
                } else {
                    // 同理这里也可以再-1，这里不减一只是为了方便展示对应的数字
                    int num = board[i][j] - '0';
                    row[i][num] = true;
                    col[j][num] = true;
                    box[(i / 3) * 3 + j / 3][num] = true;
                }
            }
        }

        backTrack(board, 0);
    }

    // 回溯算法
    public static void backTrack(char[][] board, int count) {
        if (count == spaces.size()) {
            valid = true;
            return;
        }
        // 获取当前待填充位置的下标i,j
        int i = spaces.get(count)[0], j = spaces.get(count)[1];
        // valid用于判断当前是否已经填充完毕并且已经符合，如果是true则不应该执行下边的代码
        for (int digit = 1; digit <= 9 && !valid; digit++) {
            if (!row[i][digit] && !col[j][digit] && !box[(i / 3) * 3 + j / 3][digit]) {
                // 如果满足当前for循环的数字digit，在空格位置的行、列、九宫格都不重复该数字，那么就可以转成字符插入空格
                board[i][j] = (char) (digit + '0');
                // 插入后不要忘记置为true，否则后面还能插入这个数字就不对了
                row[i][digit] = col[j][digit] = box[(i / 3) * 3 + j / 3][digit] = true;
                // 然后继续向下递归查找，看看插入当前digit后，后边的的数独是不是也都能符合
                backTrack(board, count + 1);

                // 每次深层执行完以后都要回溯，再将对应的行列九宫格置为false，然后换一个digit继续再次深层递归
                // 这里不需要再将当前位置还原成'.'了，因为后面反正会覆盖，当前给定的board一定是能够求解出数独的所以肯定会覆盖
                // 不然的话最后遍历完符合的求解后也会变成'.'，这样就相当于啥也没干了
                row[i][digit] = col[j][digit] = box[(i / 3) * 3 + j / 3][digit] = false;
                // TODO 每次都会回溯，但是终止条件是valid == true，也就是说在唯一的符合的递归分支上执行完以后，valid变成true，
                //  这样不管在哪一层递归都不会继续for循环到下一次了。
            }
        }
    }


    /** 100%， 80%
     * 方法2：回溯 + 状态压缩
     * 可用状态压缩，将数字1-9用从低位到高位二进制表示，比如某一行出现过了3和5，那么压缩状态就为row[i]=000010100这9位，
     * 从低到高分别代表1-9是否已经存在。同理col和box也是一样
     */
    public static void solveSudoku2(char[][] board){
        /**
         * 需要知道的几个点：
         * 1:  9位2进制，如何准确的将x放入从低到高的第x位？只需1<<(x-1)即可，比如x=3的话，1<<2=00000100也就是将0001左移了2位刚好表示第三位，因此前面要-1
         * 2： 如何追加放入呢，比如前面放入了3，现在再放一个5，应该变成000010100，首先0与x异或就是x,比如0^1=1, 0^0=0
         *    因此我们只需要在每次放入时，将原先的数与新增的数异或即可，原先3再放入5那就是000000100^000010000=000010100可以实现追加
         * 3： 方法1中每次循环也就是尝试填入时，是从1-9试了个遍，这里怎么尝试呢比如当前row[0]=0001010也就是目前第一行只填入过2和4，
         *    尝试对其取反即1110101，这就表示当前行可以填入得数字，然后每一次遍历尝试取最小位的1尝试填入
         *    每次循环取最小的1只需num&(-num)即可，因为计算机中二进制都是补码存储，而负数的补码就是原码取反加一，也就是取反后保留到原码最后一个1
         *    比如20的原码是00010100，补码就是11101100，可以看到最低位的1及后面的0没变，也就是做到了保留到最后一个1，
         *    然后再与原码进行按位与运算，就可以获得00000100，我们知道这里的1代表数字3，想让计算机也知道，然后放入3对应的位置
         *    可以尝试(0100)-1=011，然后统计1的个数为2，再进行1<<2也就是得到了100然后再执行第2步的追加放入的方法，也就是将原先row、col等与100再异或可以追加
         *    这里看起来可能获取100有些重复，因为num&(-num)本身就已经是了，这里主要是因为想使用第1,2步已经定义过的追加的方法，但追加需要将数字-1，因为-1后就是要左移的位数
         *    因此这里主要是为了获得100对应的数字是3，然后3-1=2，而2需要将100-1=011然后再统计1个数才能获得
         * 4： 除了空间优化，时间也有优化，方法一是每次都从1-9依次尝试，而这里是对所有的没出现过的数字进行尝试而不是1-9，比如for循环遍历的是：
         *    ~(row[i] | col[i] | box[i/3][j/3]) & 0x1ff，这里按位与0x1ff是因为int二进制可能是32位，
         *    我们只需要用到1-9位，因此前面的高位需要置0，否则和取反相关的会有问题。中间的或运算就是为了统计当前行列盒中所有数字出现的状态。
         *    最后取反就是表示没有出现过的状态，因此可以对取反后的数字依次遍历而不用对1-9每个冗余遍历
         * 5： 如何回溯？只需要再调用一遍追加某个数字的功能即可，比如原先0101然后与2异或后是0111，然后再与2异或就又变回了0101，因为异或相同0，相反1
         *     两次异或就相当于没有异或
         * 6： 每轮循环结束，需要将循环变量mask &= (mask - 1)，mask就是我们获得的需要遍历的没出现过的数字，
         *     mask &= (mask - 1)可以去除最后一个1，比如mask = 1011100,运算后就是1011000，这样就可以保证每轮去除最后一个1，从而循环体能正常从小到大遍历的每一个1
         *
         * 7： 如何再优化时间？ 只需枚举优化，即先遍历一遍所有空格，是否有只有一个符合的数字，如果有则直接填入，而不用再走递归。
         *     比如board[2][3]='.'并且这个位置的行、列、盒中只有5没出现过，那么肯定直接填入5，因为本题已经确认是有效的数独，即肯定有唯一解
         *     这样就可以少一个空格，少一层递归。否则假如board[2][3]之前也有空格，那么他之前空格的每次递归都会多走一层[2][3]后面空格的递归
         *     具体说，比如[2][3]之前还有两个位置有空格，并且可以填入1,2,3，那么1-2-5然后向下递归再回溯，2-1-5再继续递归回溯，1-3-5再继续...
         *     很明显第三个空格的5已经唯一，但每次都要再走一遍5这个递归然后再回溯到5之前再继续
         */

        // 先遍历一遍记录行列块的数字占用的状态
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                // 这里不判断空格放入空格数组是因为会进行枚举优化，到时候空格还是要更新，因此等后面再放入空格数组
                if (board[i][j] != '.'){
                    // 这里要-1是因为flip方法会让1左移x位，比如100是3，但是左移的是2位，因此要-1
                    int digit = board[i][j] - '0' - 1;
                    flip(i, j, digit);
                }
            }
        }

        // 枚举优化，找出只有一个数字可以填的空格，直接填入
        while(true){
            // change用于记录是否填入过唯一解的空格，如果两层for循环都没找到，那就说明可以直接填充的已经没了，可以结束循环了
            boolean changed = false;
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    if(board[i][j] == '.'){
                        int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;
                        // 如果去除最后一个1以后没有1，也就意味着当前空格可选的只有一个数，那么直接填入
                        // 这里位与运算 & 的两边要套上括号，否则会报错，关系运算符与位运算符优先级不确定
                        if ((mask & (mask-1)) == 0){
                            // 这里直接对mask-1而不用再num&(-num)是因为当前的mask已经只有一个1了，if循环判断过了，
                            // 因此直接-1后求1的个数就是需要左移的位数，比如0100，-1就是0011,1的个数是2即flip方法移位运算左移两位，表示0100=3
                            int digit = Integer.bitCount(mask - 1);
                            flip(i, j, digit);
                            // 然后填入数独，这里+1是因为前面会因为便于flip运算-1，但是原始数字要加回去，
                            // 几个1就表示右边有几位，+1表示当前位，这样就能正常表示数字3了，9也是同理，右边8个1，再加回去1就是9
                            board[i][j] = (char)(digit + '0' + 1);
                            changed = true;
                        }
                    }
                }
            }
            // 如果一系列循环后当前while循环的两重for循环都找不到仅有一个解的空格，那就跳出循环
            if (!changed){
                break;
            }
        }

        // 然后再重新放入待回溯的所有空格
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.'){
                    spaces.add(new int[]{i, j});
                }
            }
        }

        // 然后就回溯算法遍历所有空格依次尝试填入
        dfs(0, board);
    }

    public static void dfs(int count, char[][] board){
        if (count == spaces.size()){
            valid = true;
            return;
        }

        int i = spaces.get(count)[0], j = spaces.get(count)[1];
        // 上面是当前空格的横纵下标；下边是未填入过的，可以尝试填入的数字的二进制形式，
        // 比如0101表示数字1和3在当前行列块中都没出现过，可以使用。&0x1ff是为了保证只有前9位有效，因为一共只需要9个数字，int可能有32位
        int available = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;

        // available &= (available-1)就是为了去除最后一个1的，这样才能每次都取到不同的最低位的1。终止条件别忘了!valid
        for (; available != 0 && !valid; available &= (available-1)){
            // 取最后一个1，比如00101010经过下面运算后是00000010，利用的就是负数的补码会取反加一，也就是取反后保留最后一个1
            int mask = available & (-available);
            // 获取当前mask的1后面有几位，比如00010000，那么1的后面有4位，只需-1后就会变成00001111四个1
            // 该方法常用语求解当前数是2的几次幂，比如8是2^3，即1右边有三位数
            int bitCount = Integer.bitCount(mask - 1);
            // 记录当前数字，上面mask-1是因为flip里面会左移x位，x需要-1
            flip(i, j, bitCount);
            // 填入数字
            board[i][j] = (char) (bitCount + '0' + 1);
            dfs(count + 1, board);
            // 执行完后再进行回溯，还原回放入当前数字之前的状态
            flip(i, j, bitCount);
        }
    }

    // 用于记录行列盒已经出现过的数字的二进制形式，同时再执行一次也可以复原某个位置(回溯)
    public static void flip(int i, int j, int digit){
        // 1<<digit是找到digit+1对应的二进制置1的位置，^异或是为了在之前记录的基础上追加
        line[i] ^= (1 << digit);
        column[j] ^= (1 << digit);
        block[i / 3][j / 3] ^= (1 << digit);
    }

}
